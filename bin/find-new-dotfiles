#!/bin/bash
# find-new-dotfiles - discover and add untracked dotfiles interactively

set -euo pipefail

DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Patterns to ignore (caches, generated, ephemeral)
IGNORE_PATTERN='(cache|Cache|logs?|Log|\.log$|node_modules|__pycache__|\.Trash|Crash Reports|Service Worker|GPUCache|ShaderCache|blob_storage|Session Storage|Local Storage|IndexedDB|databases|\.DS_Store|Cookies|Preferences\.plist|WebKit|Crashpad|Code Cache|DawnCache|Network|component_crx_cache|BrowserMetrics|SafetyTips|Crowd Deny|hyphen-data|ZoomAutoUpdater|\.CFUserTextEncoding|\.cups|\.dotfiles$|\.lesshst|\.viminfo|\.zsh_history|\.bash_history|\.python_history|\.node_repl_history|\.wget-hsts|\.hushlogin|configstore|\.npm|\.pki|\.oracle_jre_usage|Electron|\.Spotlight|\.asdf|\.bun|\.docker|\.aws|\.azure|\.kube|1Password|\.zcompdump|\.zsh_sessions|_history$|\.fasd|\.mysql_history|\.tig_history|\.histfile|\.dotfiles-backup)'

# Get managed .config directories from stow packages
get_managed_configs() {
    for pkg in "$DOTFILES_DIR"/*/; do
        if [[ -d "$pkg/.config" ]]; then
            ls -1 "$pkg/.config" 2>/dev/null
        fi
    done | sort -u
}

# Get managed home dotfiles from stow packages
get_managed_home() {
    for pkg in "$DOTFILES_DIR"/*/; do
        ls -1A "$pkg" 2>/dev/null | grep '^\.'
    done | sort -u
}

# Check if item should be ignored
should_ignore() {
    local item="$1"
    echo "$item" | grep -Eq "$IGNORE_PATTERN"
}

# Get file/dir info
get_info() {
    local path="$1"
    local age size type

    if [[ -d "$path" ]]; then
        type="dir"
        size=$(du -sh "$path" 2>/dev/null | cut -f1)
    else
        type="file"
        size=$(ls -lh "$path" 2>/dev/null | awk '{print $5}')
    fi

    age=$(stat -f "%Sm" -t "%Y-%m-%d" "$path" 2>/dev/null || stat -c "%y" "$path" 2>/dev/null | cut -d' ' -f1)
    echo "$type|$size|$age"
}

# Add dotfile to stow package
add_to_dotfiles() {
    local source="$1"
    local name
    name=$(basename "$source")

    echo -e "\n${CYAN}Adding: $name${NC}"

    # Determine if it's a .config item or home dotfile
    if [[ "$source" == "$HOME/.config/"* ]]; then
        # It's a .config item
        echo -n "Package name (new or existing): "
        read -r pkg_name
        [[ -z "$pkg_name" ]] && pkg_name="$name"

        local pkg_dir="$DOTFILES_DIR/$pkg_name/.config"
        mkdir -p "$pkg_dir"

        # Move and stow
        mv "$source" "$pkg_dir/"
        echo -e "${GREEN}Moved to:${NC} $pkg_dir/$name"

        cd "$DOTFILES_DIR"
        stow -t "$HOME" -R "$pkg_name"
        echo -e "${GREEN}Stowed:${NC} $pkg_name"

    else
        # It's a home dotfile
        echo -n "Package name (new or existing): "
        read -r pkg_name
        [[ -z "$pkg_name" ]] && pkg_name="${name#.}"  # Remove leading dot for package name

        local pkg_dir="$DOTFILES_DIR/$pkg_name"
        mkdir -p "$pkg_dir"

        # Move and stow
        mv "$source" "$pkg_dir/"
        echo -e "${GREEN}Moved to:${NC} $pkg_dir/$name"

        cd "$DOTFILES_DIR"
        stow -t "$HOME" -R "$pkg_name"
        echo -e "${GREEN}Stowed:${NC} $pkg_name"
    fi
}

# Interactive menu for an item
prompt_action() {
    local path="$1"
    local name="$2"
    local info="$3"

    local type size age
    IFS='|' read -r type size age <<< "$info"

    echo -e "\n${BOLD}$name${NC} ${DIM}($type, $size, modified $age)${NC}"
    echo -e "  ${DIM}$path${NC}"
    echo -n "[a]dd to dotfiles, [s]kip, [i]gnore permanently, [v]iew, [q]uit: "

    read -r -n1 action
    echo

    case "$action" in
        a|A)
            add_to_dotfiles "$path"
            return 0
            ;;
        s|S)
            echo -e "${DIM}Skipped${NC}"
            return 0
            ;;
        i|I)
            # Add to local ignore file
            echo "$name" >> "$DOTFILES_DIR/.dotfiles-ignore"
            echo -e "${YELLOW}Added to .dotfiles-ignore${NC}"
            return 0
            ;;
        v|V)
            if [[ -d "$path" ]]; then
                ls -la "$path" | head -20
            else
                head -50 "$path" 2>/dev/null || file "$path"
            fi
            prompt_action "$path" "$name" "$info"
            return $?
            ;;
        q|Q)
            echo -e "\n${YELLOW}Quitting...${NC}"
            exit 0
            ;;
        *)
            echo -e "${DIM}Skipped${NC}"
            return 0
            ;;
    esac
}

# Load ignore list
load_ignores() {
    if [[ -f "$DOTFILES_DIR/.dotfiles-ignore" ]]; then
        cat "$DOTFILES_DIR/.dotfiles-ignore"
    fi
}

# Main
main() {
    local mode="${1:-interactive}"
    local untracked=()

    echo -e "${BOLD}${CYAN}Finding untracked dotfiles...${NC}\n"

    # Load user ignores
    local user_ignores
    user_ignores=$(load_ignores)

    # Get managed items
    local managed_configs managed_home
    managed_configs=$(get_managed_configs)
    managed_home=$(get_managed_home)

    # Scan ~/.config
    echo -e "${CYAN}Scanning ~/.config...${NC}"
    while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        should_ignore "$item" && continue
        echo "$user_ignores" | grep -qx "$item" && continue

        # Check if managed
        if ! echo "$managed_configs" | grep -qx "$item"; then
            untracked+=("$HOME/.config/$item")
        fi
    done < <(ls -1 ~/.config 2>/dev/null)

    # Scan ~/ for dotfiles
    echo -e "${CYAN}Scanning ~/...${NC}"
    while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        [[ "$item" == ".config" || "$item" == ".local" || "$item" == ".cache" ]] && continue
        should_ignore "$item" && continue
        echo "$user_ignores" | grep -qx "$item" && continue

        # Check if managed
        if ! echo "$managed_home" | grep -qx "$item"; then
            untracked+=("$HOME/$item")
        fi
    done < <(ls -1A ~ 2>/dev/null | grep '^\.')

    # Results
    echo -e "\n${BOLD}Found ${#untracked[@]} untracked dotfiles${NC}"

    if [[ ${#untracked[@]} -eq 0 ]]; then
        echo -e "${GREEN}All dotfiles are tracked!${NC}"
        exit 0
    fi

    if [[ "$mode" == "list" ]]; then
        for path in "${untracked[@]}"; do
            echo "$path"
        done
        exit 0
    fi

    # Interactive mode
    for path in "${untracked[@]}"; do
        local name info
        name=$(basename "$path")
        info=$(get_info "$path")
        prompt_action "$path" "$name" "$info"
    done

    echo -e "\n${GREEN}Done!${NC}"
}

# Parse args
case "${1:-}" in
    -l|--list)
        main "list"
        ;;
    -h|--help)
        echo "Usage: find-new-dotfiles [OPTIONS]"
        echo ""
        echo "Options:"
        echo "  -l, --list    List untracked dotfiles without prompts"
        echo "  -h, --help    Show this help"
        echo ""
        echo "Interactive commands:"
        echo "  a - Add to dotfiles repo"
        echo "  s - Skip this item"
        echo "  i - Ignore permanently (adds to .dotfiles-ignore)"
        echo "  v - View contents"
        echo "  q - Quit"
        ;;
    *)
        main "interactive"
        ;;
esac
