#!/usr/bin/env bash
# find-new-dotfiles - discover and add untracked dotfiles interactively
# shellcheck disable=SC2034  # Some variables are set for state tracking
# shellcheck disable=SC1091  # Source path is dynamic, resolved at runtime

set -euo pipefail

# --- Re-exec with newer bash if available ---
# This script requires bash 4.3+ for namerefs (local -n)
# macOS ships with bash 3.2, so use Homebrew's bash if available
if [[ -z "${DOTFILES_REEXEC:-}" ]]; then
    for bash_path in /opt/homebrew/bin/bash /usr/local/bin/bash; do
        if [[ -x "$bash_path" ]]; then
            if "$bash_path" -c 'f() { local -n x=y; }; f' 2>/dev/null; then
                export DOTFILES_REEXEC=1
                exec "$bash_path" "$0" "$@"
            fi
        fi
    done
    echo "[WARN] No bash 4.3+ found. Some features may not work." >&2
fi

# --- Global Variables ---
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"

# Source common library (required)
if [[ -f "$DOTFILES_DIR/lib/common.sh" ]]; then
    source "$DOTFILES_DIR/lib/common.sh"
else
    echo "Error: common.sh not found at $DOTFILES_DIR/lib/common.sh" >&2
    exit 1
fi

# XDG directories
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# State tracking
declare -a ADDED_ITEMS=()
declare -a SKIPPED_ITEMS=()
declare -a IGNORED_ITEMS=()

# OS detection
OS=""
ARCH=""
PKG_MANAGER=""

# --- Cleanup and signal handling ---
cleanup() {
    restore_cursor

    # Show summary if we processed anything
    if [[ ${#ADDED_ITEMS[@]} -gt 0 ]] || [[ ${#IGNORED_ITEMS[@]} -gt 0 ]]; then
        echo ""
        if [[ ${#ADDED_ITEMS[@]} -gt 0 ]]; then
            echo -e "${GREEN}Added to dotfiles:${NC}"
            for item in "${ADDED_ITEMS[@]}"; do
                echo -e "  ${GREEN}✓${NC} $item"
            done
        fi
        if [[ ${#IGNORED_ITEMS[@]} -gt 0 ]]; then
            echo -e "${YELLOW}Added to ignore list:${NC}"
            for item in "${IGNORED_ITEMS[@]}"; do
                echo -e "  ${DIM}-${NC} $item"
            done
        fi
    fi
}
trap cleanup EXIT INT TERM

# --- Logging (use common.sh functions with nicer names) ---
info()    { _log_info "$1"; }
success() { _log_success "$1"; }
warn()    { _log_warn "$1"; }
error()   { _log_error "$1"; exit 1; }

# =============================================================================
# IGNORE PATTERNS
# =============================================================================

# Patterns to ignore (caches, generated, ephemeral)
IGNORE_PATTERNS=(
    # Caches
    'cache|Cache'
    'GPUCache|ShaderCache|DawnCache|Code Cache'

    # Logs and history
    'logs?|Log|\.log$'
    '\.lesshst|\.viminfo|\.histfile'
    '\.zsh_history|\.bash_history|\.python_history|\.node_repl_history'
    '\.mysql_history|\.tig_history|\.fasd'
    '_history$'

    # System/app junk
    'node_modules|__pycache__'
    '\.Trash|Crash Reports'
    'blob_storage|Session Storage|Local Storage|IndexedDB|databases'
    '\.DS_Store|Cookies|Preferences\.plist'
    'WebKit|Crashpad|Network'
    'component_crx_cache|BrowserMetrics|SafetyTips'
    'ZoomAutoUpdater|Electron|\.Spotlight'
    '\.CFUserTextEncoding|\.cups'

    # This repo
    '\.dotfiles$|\.dotfiles-backup'

    # Other tools we don't want to track
    '\.wget-hsts|\.hushlogin'
    'configstore|\.npm|\.pki|\.oracle_jre_usage'
    '\.asdf|\.bun|\.docker|\.aws|\.azure|\.kube'
    '1Password|\.zcompdump|\.zsh_sessions'
)

# Build combined pattern
IGNORE_PATTERN=$(IFS='|'; echo "${IGNORE_PATTERNS[*]}")

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Get managed .config directories from stow packages
get_managed_configs() {
    local pkg
    for pkg in "$DOTFILES_DIR"/*/; do
        if [[ -d "$pkg/.config" ]]; then
            ls -1 "$pkg/.config" 2>/dev/null || true
        fi
    done | sort -u
}

# Get managed home dotfiles from stow packages
get_managed_home() {
    local pkg
    for pkg in "$DOTFILES_DIR"/*/; do
        # Use glob instead of ls | grep for dotfiles
        for f in "$pkg".*; do
            [[ -e "$f" ]] && basename "$f"
        done
    done 2>/dev/null | sort -u
}

# Check if item should be ignored
should_ignore() {
    local item="$1"
    echo "$item" | grep -Eq "$IGNORE_PATTERN"
}

# Get file/dir info (cross-platform)
get_info() {
    local path="$1"
    local age size type

    if [[ -d "$path" ]]; then
        type="dir"
        size=$(du -sh "$path" 2>/dev/null | cut -f1 || echo "?")
    else
        type="file"
        # shellcheck disable=SC2012  # ls for human-readable size display
        size=$(ls -lh "$path" 2>/dev/null | awk '{print $5}' || echo "?")
    fi

    # Cross-platform stat
    if [[ "$OS" == "macos" ]]; then
        age=$(stat -f "%Sm" -t "%Y-%m-%d" "$path" 2>/dev/null || echo "unknown")
    else
        age=$(stat -c "%y" "$path" 2>/dev/null | cut -d' ' -f1 || echo "unknown")
    fi

    echo "$type|$size|$age"
}

# Load user ignore list
load_ignores() {
    if [[ -f "$DOTFILES_DIR/.dotfiles-ignore" ]]; then
        cat "$DOTFILES_DIR/.dotfiles-ignore"
    fi
}

# =============================================================================
# DOTFILE MANAGEMENT
# =============================================================================

# Validate package name
validate_package_name() {
    local name="$1"
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        warn "Invalid package name. Use only letters, numbers, dash, underscore."
        return 1
    fi
    return 0
}

# Add dotfile to stow package
add_to_dotfiles() {
    local source="$1"
    local name
    name=$(basename "$source")

    echo -e "\n${CYAN}Adding: $name${NC}"

    # Determine if it's a .config item or home dotfile
    local is_config=false
    [[ "$source" == "$XDG_CONFIG_HOME/"* ]] && is_config=true

    # Prompt for package name
    local default_pkg
    if [[ "$is_config" == true ]]; then
        default_pkg="$name"
    else
        default_pkg="${name#.}"  # Remove leading dot
    fi

    echo -n "Package name [$default_pkg]: "
    read -r pkg_name
    [[ -z "$pkg_name" ]] && pkg_name="$default_pkg"

    # Validate
    if ! validate_package_name "$pkg_name"; then
        return 1
    fi

    # Determine destination
    local pkg_dir
    if [[ "$is_config" == true ]]; then
        pkg_dir="$DOTFILES_DIR/$pkg_name/.config"
    else
        pkg_dir="$DOTFILES_DIR/$pkg_name"
    fi

    mkdir -p "$pkg_dir"

    # Move file
    if mv "$source" "$pkg_dir/"; then
        echo -e "${GREEN}Moved to:${NC} $pkg_dir/$name"
    else
        warn "Failed to move $source"
        return 1
    fi

    # Stow package
    if stow -d "$DOTFILES_DIR" -t "$HOME" -R "$pkg_name" 2>/dev/null; then
        echo -e "${GREEN}Stowed:${NC} $pkg_name"
        ADDED_ITEMS+=("$name → $pkg_name")
        return 0
    else
        warn "Failed to stow $pkg_name"
        # Try to restore
        if [[ "$is_config" == true ]]; then
            mv "$pkg_dir/$name" "$XDG_CONFIG_HOME/" 2>/dev/null || true
        else
            mv "$pkg_dir/$name" "$HOME/" 2>/dev/null || true
        fi
        return 1
    fi
}

# Add to permanent ignore list
add_to_ignore() {
    local name="$1"
    echo "$name" >> "$DOTFILES_DIR/.dotfiles-ignore"
    IGNORED_ITEMS+=("$name")
    echo -e "${YELLOW}Added to .dotfiles-ignore${NC}"
}

# =============================================================================
# INTERACTIVE PROMPT
# =============================================================================

prompt_action() {
    local path="$1"
    local name="$2"
    local info="$3"

    local type size age
    IFS='|' read -r type size age <<< "$info"

    while true; do
        echo ""
        echo -e "${BOLD}$name${NC} ${DIM}($type, $size, modified $age)${NC}"
        echo -e "  ${DIM}$path${NC}"
        echo -n "[a]dd to dotfiles, [s]kip, [i]gnore permanently, [v]iew, [q]uit: "

        read -r -n1 action
        echo

        case "$action" in
            a|A)
                add_to_dotfiles "$path" || true
                return 0
                ;;
            s|S)
                echo -e "${DIM}Skipped${NC}"
                SKIPPED_ITEMS+=("$name")
                return 0
                ;;
            i|I)
                add_to_ignore "$name"
                return 0
                ;;
            v|V)
                echo ""
                echo -e "${DIM}────────────────────────────────────────${NC}"
                if [[ -d "$path" ]]; then
                    # shellcheck disable=SC2012  # ls for interactive display
                    ls -la "$path" 2>/dev/null | head -20
                else
                    head -50 "$path" 2>/dev/null || file "$path"
                fi
                echo -e "${DIM}────────────────────────────────────────${NC}"
                # Loop continues - will show prompt again
                ;;
            q|Q)
                echo -e "\n${YELLOW}Quitting...${NC}"
                exit 0
                ;;
            *)
                echo -e "${DIM}Skipped${NC}"
                SKIPPED_ITEMS+=("$name")
                return 0
                ;;
        esac
    done
}

# =============================================================================
# MAIN
# =============================================================================

main() {
    local mode="${1:-interactive}"

    # Detect OS for cross-platform stat
    _detect_os
    OS="$DETECTED_OS"
    ARCH="$DETECTED_ARCH"
    PKG_MANAGER="$DETECTED_PKG_MANAGER"

    # Check if running interactively
    if [[ "$mode" == "interactive" ]] && ! is_interactive; then
        error "Not running in a terminal. Use --list for non-interactive mode."
    fi

    echo -e "${BOLD}${CYAN}Finding untracked dotfiles...${NC}"
    echo ""

    # Load user ignores
    local user_ignores
    user_ignores=$(load_ignores)

    # Get managed items
    local managed_configs managed_home
    managed_configs=$(get_managed_configs)
    managed_home=$(get_managed_home)

    # Collect untracked items
    local -a untracked=()

    # Scan XDG_CONFIG_HOME
    info "Scanning $XDG_CONFIG_HOME..."
    while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        should_ignore "$item" && continue
        echo "$user_ignores" | grep -qxF "$item" && continue

        # Check if managed
        if ! echo "$managed_configs" | grep -qxF "$item"; then
            untracked+=("$XDG_CONFIG_HOME/$item")
        fi
    done < <(ls -1 "$XDG_CONFIG_HOME" 2>/dev/null || true)

    # Scan ~/ for dotfiles
    info "Scanning $HOME..."
    for f in "$HOME"/.*; do
        [[ -e "$f" ]] || continue
        local item
        item=$(basename "$f")
        [[ "$item" == "." || "$item" == ".." ]] && continue
        # Skip standard XDG directories
        [[ "$item" == ".config" || "$item" == ".local" || "$item" == ".cache" ]] && continue
        should_ignore "$item" && continue
        echo "$user_ignores" | grep -qxF "$item" && continue

        # Check if managed
        if ! echo "$managed_home" | grep -qxF "$item"; then
            untracked+=("$HOME/$item")
        fi
    done

    # Results
    echo ""
    echo -e "${BOLD}Found ${#untracked[@]} untracked dotfiles${NC}"

    if [[ ${#untracked[@]} -eq 0 ]]; then
        echo -e "${GREEN}All dotfiles are tracked!${NC}"
        exit 0
    fi

    # List mode - just print and exit
    if [[ "$mode" == "list" ]]; then
        echo ""
        for path in "${untracked[@]}"; do
            local name info
            name=$(basename "$path")
            info=$(get_info "$path")
            local type size age
            IFS='|' read -r type size age <<< "$info"
            printf "%-40s %s  %s  %s\n" "$path" "$type" "$size" "$age"
        done
        exit 0
    fi

    # Interactive mode
    echo -e "${DIM}Press 'q' at any prompt to quit${NC}"

    for path in "${untracked[@]}"; do
        local name info
        name=$(basename "$path")
        info=$(get_info "$path")
        prompt_action "$path" "$name" "$info"
    done

    echo -e "\n${GREEN}Done!${NC}"
}

# =============================================================================
# CLI
# =============================================================================

show_help() {
    cat << 'EOF'
Usage: find-new-dotfiles [OPTIONS]

Discover untracked dotfiles and optionally add them to your dotfiles repo.

Options:
  -l, --list    List untracked dotfiles without prompts (with details)
  -h, --help    Show this help

Interactive commands:
  a - Add to dotfiles repo (prompts for package name)
  s - Skip this item
  i - Ignore permanently (adds to .dotfiles-ignore)
  v - View contents (shows first 50 lines or directory listing)
  q - Quit

Environment:
  DOTFILES_DIR    Path to dotfiles directory (default: ~/.dotfiles)
  XDG_CONFIG_HOME Override config directory (default: ~/.config)

Examples:
  find-new-dotfiles              # Interactive mode
  find-new-dotfiles --list       # List untracked files with details
  find-new-dotfiles --list | wc  # Count untracked files
EOF
}

case "${1:-}" in
    -l|--list)
        main "list"
        ;;
    -h|--help)
        show_help
        ;;
    *)
        main "interactive"
        ;;
esac
